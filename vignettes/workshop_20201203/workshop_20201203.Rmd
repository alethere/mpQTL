---
title: "mpQTL Workshop on SNP array intensities and SNP dosage probabilities"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mpQTL Workshop on SNP array intensities and SNP dosage probabilities}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE, purl=F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, eval=F}
library(mpQTL)
```

```{r, include = FALSE, purl=F}
devtools::load_all()
```


# Introduction
`mpQTL` is an R package for single marker association analysis in structured populations of any ploidy (e.g. multiparental populations, GWAS panels or a combination of them). Input genotypic data can be both biallelic (continuous or discrete SNP data) or multiallelic (haplotypes). 
The present vignette will show how to use `mpQTL` to run a QTL analysis using continuous SNP data, such as SNP array intensities or SNP dosage probabilities.  

# Load  example data
```{r data_load}
# Load  example data ------------------------
load("workshop_data.RData")

# it contains
head(mrksel)
head(indsel)
head(map)
head(phenotypes)

```

# Chunkwise data import by 'ff'
In our pipeline, array intensity ratios and dosage probabilities can be found in one of the output of `fitPoly`. However, those files are often very big, so that loading them on the computer RAM might be impracticable.
Here, we included a tip to overcome this issue, using chunkwise operations provided by the `ff` package. Please, see the `ff` manual (in the workshop folder) for a detailed explanation.
A useful feature of `ff` is the possibility to subset data, while importing it chunckwise. In fact, part of the dataset might be redundant or unnecessary (e.g. one could need a subset of individuals only or a subset of well performing markers).


```{r, results='hide', message=FALSE, warning=FALSE}
# Chunkwise data import by 'ff' -----------------------------
library("ff")
library("ffbase")

## preview
readLines("scores.dat", 10)

scores_preview <- read.delim.ffdf(file="scores.dat",
                                  nrows = 10)
scores_preview

```



```{r, results='hide'}
## import data and subset based on marker names (or sample names)
names_ffdf <- read.delim.ffdf(file="scores.dat",
                                     transFUN = function(x, n = mrksel, m = indsel) {
                                       idx <- x[,2] %in% n & x[,3] %in% m
                                       x[idx, 1:3]
                                     })
names_ffdf
rownames(names_ffdf) <- NULL

data_ffdf <- read.delim.ffdf(file="scores.dat",
                             transFUN = function(x, n = mrksel, m = indsel){
                               idx <- x[,2] %in% n & x[,3] %in% m
                               x[idx, c(4:9,12)]
                             })
data_ffdf
rownames(data_ffdf) <- NULL

data_ffmat <- ffbase:::as.ff_matrix.ffdf(data_ffdf)
data_ffmat


```

If the dataset has been reduced enough in size, it is possible to load it on RAM (i.e. convert the ff object into the correspondent RAM object). To do that, use the square brackets (e.g. data_ffmat[]). Make sure that row names are not inherited by the ff object (using ramattribs), since they can occupy memory.
```{r}
## get the RAM object
ramattribs(data_ffmat[1:10,])
data <- data_ffmat[]
data[1:5,]
names <- names_ffdf[]
head(names)
```

Now, we can remove ff objects and clear reference to flat files. Optionally, it is possible to save the ff flat files to access them in a later stage.
```{r}
# ## save and load
# ffsave(data_ffmat, file=""vignettes/workshop_20201203/ff_files/data_ffmat")
# ffload("vignettes/workshop_20201203/ff_files/data_ffmat")

## delete ff files
delete(names_ffdf, data_ffdf, data_ffmat, scores_preview)
rm(names_ffdf, data_ffdf, data_ffmat, scores_preview)
gc()
detach("package:ffbase", unload=TRUE)
detach("package:ff", unload=TRUE)
detach("package:bit", unload=TRUE)

```


# Transform and reshape data
SNP array intensity ratios $Y/(X+Y)$ are already available in the output of fitPoly. We just need to reshape them into a matrix, with markers in rows and individuals in column (better to add marker names and individual names).
```{r}
# Transform and reshape data ---------------------------
# + reshape ratios -------------------
ratios <- matrix(data[,1], nrow = length(unique(names$MarkerName)), byrow = T)
dim(ratios)
ratios <- round(ratios,4)

rownames(ratios) <- unique(names$MarkerName)
colnames(ratios) <- unique(names$SampleName)
```

```{r}
ratios[1:5,1:5]
```

Dosage probabilities need to be transformed in a format that can be accepted by mpQTL. The simplest way is to calculate a weighted mean of the dosage probabilities, where the weigth of each probability is the corresponding dosage. Then, all is normalized to 1, so that the final variable will range between 0 and 1 (same as for the intensity ratios). 

```{r, results='hide'}
# + dosage probabilities ------------------
Bfreq <- dosP2Bfreq(data[,2:6])
dim(Bfreq)
Bfreq[1:9]

attributes(Bfreq)
class(Bfreq)
typeof(Bfreq)
Bfreq <- round(Bfreq,4)

Bfreq <- matrix(Bfreq, nrow = length(unique(names$MarkerName)), byrow = T)
dim(Bfreq)
Bfreq[1:5,1:5]

rownames(Bfreq) <- unique(names$MarkerName)
colnames(Bfreq) <- unique(names$SampleName)

```

```{r}
Bfreq[1:5,1:5]
range(c(Bfreq))
```

Please, notice that filtration steps are not included in `mpQTL`. Running those screenings might result in missing genotypes (unrelible genotypes are set to NA). Here, we randomly include some missing values to illustrate how the next functions will handle them.

```{r}
# Simulate filtration steps ----------------------------
set.seed(3)
naidx <- sample(1:length(ratios), 100)
ratios[naidx] <- NA
Bfreq[naidx] <- NA
```


# Kinship calculation and genotype imputation
For all the `mpQTL` functions used in the next steps, you can also refer to the main `mpQTL` vignette (distributed last December) for more details.
A kinship matrix between individuals can be automatically calculated running the main `mpQTL` function `map.QTL`. However, especially when working on big datasets, it can be convenient to calculate the kinship matrix in advance (and only once) and provide it to `map.QTL`. This can save time and ensure consistency in your analyses. The same is valid for imputaion of missing genotypes. Therefore, in this vignette these two steps will be run before the actual association analysis. 

## Kinship
```{r}
# Kinship calculation and genotype imputation ------------------
## + Kinship matrix -----------
## Used for knn imputation or structure correction.
## To calculate a kinship using a subset of markers see sample.cM
Kr <- calc.K(t(ratios))
Kr[1:5,1:5]

Kp <- calc.K(t(Bfreq))
Kp[1:5,1:5]


## visualize kinship
# pcoa.plot(Kr)
```

## Genotypes imputation
Missing genotypes can be imputed using `impute.knn`. When continuos data (such as intensity ratios and dosage probabilities) are provided, `impute.knn` will return the genotype mean of the n most similar kneighbors. 
```{r}
## + geno imputation --------------------
## Since we provide K, map is not needed
sum(is.na(ratios))
ratios2 <- impute.knn(ratios,
                      ploidy = 4,
                      kneighbors = 20,
                      K=Kr)
ratios2[1:5,1:5]

sum(is.na(Bfreq))
Bfreq2 <- impute.knn(Bfreq,
                     ploidy = 4,
                     kneighbors = 20,
                     K=Kp)

```

# Run association models

## Input matrices order
Association models can be run by `map.QTL`. This function assumes that all the input matrices (or vectors) provided by the user consistently refer to the same markers (in the same order) and the same individuals (in the same order). The function `inputOrder` can be used (if marker names and individual names are specified), to make sure this requirement is met.
```{r}
# Run association models --------------------------------
# + Input matrices order -------------------
ordInp_ratios <- inputOrder(ratios2, pheno = phenotypes, map = map, K = Kr)
str(ordInp_ratios)

ordInp_Bfreq <- inputOrder(Bfreq2, pheno = phenotypes, map = map, K = Kp)

```

## Li & Ji threshold
As an alternative to permutations, the method of Li & Ji can be used to a adjust significance for multiple testing.
```{r}
# + Li & Ji threshold --------------------
ratios_thr <- thr.LiJi(ordInp_ratios$geno,
                       chrom = ordInp_ratios$map$chromosome,
                       ploidy = 4)
ratios_thr



```

```{r, results='hide', warning=FALSE}
Bfreq_thr <- thr.LiJi(ordInp_Bfreq$geno,
                       chrom = ordInp_Bfreq$map$chromosome,
                       ploidy = 4)
```


## Naive model and K model
Now, we run the association models using `map.QTL`.
```{r, warning=FALSE}
# + Naive model and K model -------------------------
## using ratios
ratios_naive <- map.QTL(phenotypes = ordInp_ratios$pheno,
                        genotypes = ordInp_ratios$geno,
                        ploidy = 4,
                        K = ordInp_ratios$K,
                        K_identity = T, #to force naive
                        # impute = F, #not needed, since we provided imputed genotypes
                        map = ordInp_ratios$map,
                        no_cores = 6)

ratios_K <- map.QTL(phenotypes = ordInp_ratios$pheno,
                    genotypes = ordInp_ratios$geno,
                    ploidy = 4,
                    K = ordInp_ratios$K,
                    map = ordInp_ratios$map,
                    no_cores = 6)



```

```{r, results='hide', warning=FALSE}
## using dosage probabilities
Bfreq_naive <- map.QTL(phenotypes = ordInp_Bfreq$pheno,
                        genotypes = ordInp_Bfreq$geno,
                        ploidy = 4,
                        K = ordInp_Bfreq$K,
                        K_identity = T, #to force naive
                        # impute = F, #not needed, since we provided imputed genotypes
                        map = ordInp_Bfreq$map,
                        no_cores = 6)

Bfreq_K <- map.QTL(phenotypes = ordInp_Bfreq$pheno,
                   genotypes = ordInp_Bfreq$geno,
                   ploidy = 4,
                   K = ordInp_Bfreq$K,
                   map = ordInp_Bfreq$map,
                   no_cores = 6)
```



## Manhattan plots
```{r, fig.height = 3, fig.width = 6, fig.align = "center"}
# + Manhattan plots -------------------------
## plots for ratios
skyplot(-log10(ratios_naive$pheno01$pval),
        map = ordInp_ratios$map,
        chromspace = 0,
        threshold = -log10(ratios_thr$threshold),
        main="naive model using ratios")

skyplot(-log10(ratios_K$pheno01$pval),
        map = ordInp_ratios$map,
        chromspace = 0,
        threshold = -log10(ratios_thr$threshold),
        main="K model using ratios")


## plots for dosage prob.
skyplot(-log10(Bfreq_naive$pheno01$pval),
        map = ordInp_Bfreq$map,
        chromspace = 0,
        threshold = -log10(Bfreq_thr$threshold),
        main="naive model using dosage prob.")

skyplot(-log10(Bfreq_K$pheno01$pval),
        map = ordInp_Bfreq$map,
        chromspace = 0,
        threshold = -log10(Bfreq_thr$threshold),
        main="K model using dosage prob.")
```


## Genotype-phenotype plots
```{r}
# + Genotype-phenotype plots -----------------------------
## peak marker for ratios
ratios_K$pheno01$pval[which.max(-log10(ratios_K$pheno01$pval))]
plot(ordInp_ratios$geno["mrk050949",],
     ordInp_ratios$pheno[,1],
     xlim = c(0,1),
     xlab = "ratios",
     ylab = "phenotype")

## peak marker for dosage prob.
Bfreq_K$pheno01$pval[which.max(-log10(Bfreq_K$pheno01$pval))]
plot(ordInp_Bfreq$geno["mrk050949",],
     ordInp_Bfreq$pheno[,1],
     xlim = c(0,1),
     xlab = "dosage Prob.",
     ylab = "phenotype")


```

# B allele frequency plots

```{r, fig.height = 3, fig.width = 6, fig.align = "center"}
# B allele frequency plots ---------------------------
library(scales)

ordMapRatio <- inputOrder(ratios[rownames(ratios) %in% map$marker[map$chromosome != 0],], map = map)
# colnames(ordMapRatio$geno)
# str(ordMapRatio)

skyplot(ordMapRatio$geno[,"ind010"],
        map = ordMapRatio$map, #[physmap$physical_chr!=0,]
        ylim = c(0,1.1),
        pch = 20,
        cex = 0.9,
        ylab = "ratios",
        col = alpha(c("dodgerblue4","dodgerblue"),0.2),
        chromspace = 0,
        main="ind010")

skyplot(ordMapRatio$geno[,"ind011"],
        map = ordMapRatio$map, #[physmap$physical_chr!=0,]
        ylim = c(0,1.1),
        pch = 20,
        cex = 0.9,
        ylab = "ratios",
        col = alpha(c("dodgerblue4","dodgerblue"),0.2),
        chromspace = 0,
        main="ind011")


```


```{r}
hist(ordMapRatio$geno[,"ind010"],
     breaks = 500,
     xlim = c(0,1),
     main="ind010",
     xlab = "ratios")
hist(ordMapRatio$geno[,"ind011"],
     breaks = 500,
     xlim = c(0,1),
     main="ind011",
     xlab = "ratios")
```


```{r, fig.height = 3, fig.width = 6, fig.align = "center"}
ordMapBfreq <- inputOrder(Bfreq[rownames(Bfreq) %in% map$marker[map$chromosome != 0],], map = map)

skyplot(ordMapBfreq$geno[,"ind011"],
        map = ordMapBfreq$map, #[physmap$physical_chr!=0,]
        ylim = c(0,1.1),
        pch = 20,
        cex = 0.9,
        ylab = "Dosage Prob.",
        col = alpha(c("dodgerblue4","dodgerblue"),0.2),
        chromspace = 0,
        main="ind011")

```

